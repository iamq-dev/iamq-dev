<!DOCTYPE html>
<html lang="en" class="h-full bg-gray-900 text-gray-100">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sliding Puzzle Game</title>
    
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Use a modern, clean font */
        body {
            font-family: 'Inter', sans-serif;
            overscroll-behavior: none; /* Prevent pull-to-refresh on mobile */
        }

        /* Responsive game board container */
        #game-board-container {
            position: relative; /* For absolute player positioning */
            width: 90vw;
            height: 90vw;
            max-width: 800px;
            max-height: 800px;
            background-color: #1F2937; /* gray-800 */
            padding: 8px; /* Added padding */
            border-radius: 8px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
            touch-action: none; /* Disable browser handling of gestures on the board */
        }

        /* The grid itself, now just for static cells */
        #game-board {
            display: grid;
            grid-template-columns: repeat(14, 1fr); /* Updated to 14 */
            grid-template-rows: repeat(14, 1fr); /* Updated to 14 */
            width: 100%;
            height: 100%;
            gap: 4px;
        }

        /* Base cell styling */
        .cell {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem; /* Adjusted for 14x14 */
            transition: background-color 0.1s ease-in-out, transform 0.1s ease;
            background-color: #374151; /* gray-700 */
            border-radius: 4px;
        }

        /* Cell type styles */
        .cell-wall {
            background-color: #111827; /* gray-900 */
            color: #d97706; /* amber-600 */
            font-size: 1rem; /* Smaller emoji for bricks */
            border-radius: 0;
        }
        .cell-block {
            background-color: #4B5563; /* gray-600 */
        }
        .cell-cookie {
            background-color: transparent; /* Cookie is just an emoji */
            font-size: 1rem;
        }
        .cell-empty {
            /* No emoji, just the background */
        }
        
        .cell-empty {
            /* Background color is set by validation */
        }

        .cell-empty-text {
            color: #4B5563; /* gray-600 */
            font-size: 1rem;
            font-weight: bold;
            user-select: none; /* Make it so you don't accidentally select the 'x' */
        }
        
        /* Validation styles (always on) */
        .cell-empty.cell-unreachable {
            background-color: #b91c1c; /* red-700 */
        }
        /* Reachable styles are now set by HSL in JS */


        /* --- New Animated Player --- */
        #player {
            position: absolute;
            top: 0; /* Will be set by JS */
            left: 0; /* Will be set by JS */
            
            /* Sizing is now set by JS in pixels */
            
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem; /* Adjusted for 14x14 */
            
            background-color: #3B82F6; /* blue-500 */
            border-radius: 4px;
            transform: scale(1.1); /* Slightly larger */
            box-shadow: 0 0 15px rgba(59, 130, 246, 0.7);
            
            /* The Animation! */
            transition: transform 0.3s ease-in-out;
            
            /* Prevent user from dragging the emoji */
            user-select: none; 
            z-index: 10;
        }

        /* Build mode cursor */
        #game-board .cell:not(.cell-wall) {
            cursor: pointer;
        }
        #game-board .cell:not(.cell-wall):hover {
            transform: scale(1.05);
            opacity: 0.8;
            background-color: #4a5a70;
        }
    </style>
</head>
<body class="h-full flex flex-col items-center justify-center p-4">

    <h1 class="text-3xl font-bold mb-4">Sliding Puzzle</h1>
    
    <!-- Container for the board and player -->
    <div id="game-board-container">
        <!-- The static grid (walls, blocks, etc.) -->
        <div id="game-board">
            <!-- Cells are generated by JS -->
        </div>
        <!-- The animated player element -->
        <div id="player">ðŸ§Š</div>
    </div>

    <!-- UI Controls -->
    <div class="flex flex-col items-center w-full max-w-xl">
        
        <div class="flex justify-between w-full mt-4">
            <h2 class="text-2xl font-bold">Score: <span id="score-display" class="text-yellow-400">0</span></h2>
        </div>

        <p id="message-area" class="mt-2 h-10 text-center text-gray-400 transition-colors duration-300">
            Click to build, Right-click for cookies, Arrow Keys (or Swipe) to play.
        </p>
        
        <div class="mt-4 flex space-x-4">
            <button id="reset-button" class="px-4 py-2 bg-blue-600 text-white rounded-lg font-semibold shadow-md hover:bg-blue-700 transition">
                Reset Player
            </button>
            <button id="random-button" class="px-4 py-2 bg-green-600 text-white rounded-md cursor-pointer font-semibold hover:bg-green-700 transition disabled:opacity-50 disabled:cursor-wait">
                Randomize
            </button>
        </div>
    </div>


    <script type="module">
        // --- Constants ---
        const ROWS = 14; 
        const COLS = 14; 
        const PLAYER = 6;
        const WALL = 1;
        const BLOCK = 8;
        const COOKIE = 7;
        const EMPTY = 0;

        const boardContainer = document.getElementById('game-board-container');
        const boardElement = document.getElementById('game-board');
        const playerElement = document.getElementById('player');
        const messageArea = document.getElementById('message-area');
        const scoreDisplay = document.getElementById('score-display');
        const resetButton = document.getElementById('reset-button');
        const randomButton = document.getElementById('random-button');
        
        // --- Game State ---
        let gameBoard = [];
        let playerPos = { r: 1, c: 1 }; // Default start
        let playerStartPos = { r: 1, c: 1 }; // For reset
        let moveCosts = new Map(); // Stores move cost for heat map
        let score = 0;
        let isAnimating = false; // Prevent moves during animation
        
        // Touch State
        let touchStartX = 0;
        let touchStartY = 0;
        
        // --- Sizing ---
        let boardDim = { width: 0, height: 0, cellW: 0, cellH: 0, gap: 4, padding: 8 };

        // --- Game Logic ---

        /**
         * Initializes the game state and board
         */
        function initGame() {
            gameBoard = createInitialMatrix(); // Sets playerStartPos
            
            // 2. Set event listeners
            setupEventListeners();

            // 3. Calculate initial dimensions
            calculateDimensions();

            // 4. Render the static board for the first time
            renderBoard();
            
            // 5. Position player for the first time (no animation)
            snapPlayerToPosition(playerStartPos.r, playerStartPos.c);
            
            // 6. Run initial validation
            validatePuzzle();
            
            // 7. Set initial message
            messageArea.textContent = 'Click to build, Right-click for cookies, Arrow Keys (or Swipe) to play.';
        }

        /**
         * Calculates and stores the board's pixel dimensions
         */
        function calculateDimensions() {
            boardDim.width = boardContainer.clientWidth;
            boardDim.height = boardContainer.clientHeight;
            
            const gridWidth = boardElement.clientWidth;
            const gridHeight = boardElement.clientHeight;
            
            boardDim.cellW = (gridWidth - (COLS - 1) * boardDim.gap) / COLS;
            boardDim.cellH = (gridHeight - (ROWS - 1) * boardDim.gap) / ROWS;
            
            // Update player size in pixels
            playerElement.style.width = `${boardDim.cellW}px`;
            playerElement.style.height = `${boardDim.cellH}px`;
        }

        /**
         * Creates the initial game board matrix
         */
        function createInitialMatrix() {
            let matrix = [];
            for (let i = 0; i < ROWS; i++) {
                let row = [];
                for (let j = 0; j < COLS; j++) {
                    if (i === 0 || i === ROWS - 1 || j === 0 || j === COLS - 1) {
                        row.push(WALL);
                    } else {
                        row.push(EMPTY);
                    }
                }
                matrix.push(row);
            }

            // Set player start position
            playerStartPos = { r: 1, c: 1 };
            
            // New 35-block layout from user
             const blockPositions = [
                [1, 5], [1, 10],
                [2, 5], [2, 7], [2, 11],
                [3, 7], [3, 9],
                [4, 4], [4, 9],
                [5, 1], [5, 6], [5, 7], [5, 9], [5, 12],
                [6, 5],
                [7, 2], [7, 4], [7, 5], [7, 7], [7, 8], [7, 9],
                [8, 9], [8, 10],
                [9, 1], [9, 5], [9, 7], [9, 9], [9, 12],
                [10, 3], [10, 7],
                [11, 7], [11, 9], [11, 11],
                [12, 4], [12, 9]
            ];
            
            for (const [r, c] of blockPositions) {
                if (r > 0 && r < ROWS - 1 && c > 0 && c < COLS - 1) {
                    matrix[r][c] = BLOCK;
                }
            }

            // Place the player in the data array
            matrix[playerStartPos.r][playerStartPos.c] = PLAYER;
            playerPos = { r: playerStartPos.r, c: playerStartPos.c };
            
            return matrix;
        }

        /**
         * Renders the STATIC gameBoard state (walls, blocks, empty) to the DOM
         */
        function renderBoard() {
            boardElement.innerHTML = ''; // Clear the board
            let maxCost = 0;
            moveCosts.forEach(cost => {
                if (cost > maxCost) maxCost = cost;
            });
            
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const cell = document.createElement('div');
                    cell.classList.add('cell');
                    cell.dataset.r = r;
                    cell.dataset.c = c;
                    
                    const cellValue = gameBoard[r][c];
                    const cellKey = `${r},${c}`;

                    // Assign class and content based on cell value
                    switch (cellValue) {
                        case WALL:
                            cell.classList.add('cell-wall');
                            cell.textContent = 'ðŸ§±';
                            break;
                        case BLOCK:
                            cell.classList.add('cell-block');
                            cell.textContent = 'â¬›';
                            break;
                        case COOKIE:
                            cell.classList.add('cell-cookie');
                            cell.textContent = 'ðŸª';
                            break;
                        case PLAYER: // Player's *spot* is just empty
                        case EMPTY:
                            cell.classList.add('cell-empty');
                            cell.textContent = ''; 
                            break;
                    }
                    
                    // Visual Validation Logic (Always On)
                    if (cellValue === EMPTY || cellValue === PLAYER || cellValue === COOKIE) {
                        if (moveCosts.has(cellKey)) {
                            // Heat Map Coloring
                            const cost = moveCosts.get(cellKey);
                            // Normalize cost: 0 = brightest, maxCost = darkest
                            const lightness = 90 - (cost / (maxCost + 1)) * 50; // 90% (bright) to 40% (dark)
                            const saturation = 70 + (cost / (maxCost + 1)) * 30; // 70% to 100%
                            cell.style.backgroundColor = `hsl(140, ${saturation}%, ${lightness}%)`;
                            cell.style.color = `hsl(140, ${saturation}%, ${lightness - 50}%)`; // Darker text
                        } else {
                            cell.classList.add('cell-unreachable');
                            cell.style.color = '#7f1d1d'; // dark-red-800
                        }
                    }
                    
                    boardElement.appendChild(cell);
                }
            }
        }
        
        /**
         * Snaps the player element to a position *without* animation
         */
        function snapPlayerToPosition(r, c) {
            // Recalculate dimensions in case of resize
            calculateDimensions();
            const { x, y } = getPixelCoords(r, c);
            
            // Disable transitions
            playerElement.style.transition = 'none';
            // Set position
            playerElement.style.transform = `translate(${x}px, ${y}px)`;
            
            // Force a browser reflow (to apply the 'none' transition)
            playerElement.offsetHeight; 
            
            // Re-enable transitions for next move
            playerElement.style.transition = ''; 
        }
        
        /**
         * Moves the player element to a new position *with* animation
         */
        function animatePlayerToPosition(r, c) {
            const { x, y } = getPixelCoords(r, c);
            
            // Calculate distance for dynamic speed
            const dist = Math.max(Math.abs(r - playerPos.r), Math.abs(c - playerPos.c));
            const duration = Math.min(Math.max(0.05 * dist, 0.1), 0.4); // Faster animation
            
            playerElement.style.transition = `transform ${duration}s ease-out`;
            playerElement.style.transform = `translate(${x}px, ${y}px)`;
        }
        
        /**
         * Converts (r, c) grid coordinates to (x, y) pixel coordinates
         * NOW ACCOUNTS FOR PADDING
         */
        function getPixelCoords(r, c) {
            // (cell index * cell width) + (cell index * gap width) + container padding
            const x = c * boardDim.cellW + c * boardDim.gap + boardDim.padding;
            const y = r * boardDim.cellH + r * boardDim.gap + boardDim.padding;
            return { x, y };
        }

        /**
         * Sets up all necessary event listeners
         */
        function setupEventListeners() {
            // Arrow key movement
            window.addEventListener('keydown', handleKeyDown);

            // Left-Click (for build mode)
            boardElement.addEventListener('click', handleLeftClick);
            
            // Right-Click (for cookies)
            boardElement.addEventListener('contextmenu', handleRightClick);
            
            // Reset button
            resetButton.addEventListener('click', resetPlayer);

            // Randomize button
            randomButton.addEventListener('click', generateRandomLayout);
            
            // Listen for animation end
            playerElement.addEventListener('transitionend', () => {
                isAnimating = false;
            });
            
            // Handle window resize
            window.addEventListener('resize', () => {
                calculateDimensions();
                snapPlayerToPosition(playerPos.r, playerPos.c);
            });
            
            // NEW: Touch events for mobile swipe
            boardContainer.addEventListener('touchstart', handleTouchStart, { passive: false });
            boardContainer.addEventListener('touchend', handleTouchEnd, { passive: false });
            boardContainer.addEventListener('touchmove', handleTouchMove, { passive: false });
        }
        
        /**
         * Handles Touch Start
         */
        function handleTouchStart(e) {
            touchStartX = e.changedTouches[0].screenX;
            touchStartY = e.changedTouches[0].screenY;
        }

        /**
         * Handles Touch Move (Prevent Scroll)
         */
        function handleTouchMove(e) {
            // Only prevent default if interacting with the board
            e.preventDefault(); 
        }

        /**
         * Handles Touch End (Gesture Recognition)
         */
        function handleTouchEnd(e) {
            if (isAnimating) return;

            const touchEndX = e.changedTouches[0].screenX;
            const touchEndY = e.changedTouches[0].screenY;
            
            const diffX = touchEndX - touchStartX;
            const diffY = touchEndY - touchStartY;
            
            const threshold = 30; // Min pixels to be considered a swipe

            if (Math.abs(diffX) < threshold && Math.abs(diffY) < threshold) {
                return; // Tap, let click handler fire
            }

            if (Math.abs(diffX) > Math.abs(diffY)) {
                // Horizontal
                if (diffX > 0) movePlayer(0, 1); // Right
                else movePlayer(0, -1); // Left
            } else {
                // Vertical
                if (diffY > 0) movePlayer(1, 0); // Down
                else movePlayer(-1, 0); // Up
            }
        }
        
        /**
         * Handles Left-Click events (toggles Blocks)
         */
        function handleLeftClick(e) {
            if (isAnimating) return; 
            
            const cell = e.target.closest('.cell');
            if (!cell) return;

            const r = parseInt(cell.dataset.r);
            const c = parseInt(cell.dataset.c);
            const cellValue = gameBoard[r][c];

            if (cellValue === WALL) return;
            
            // Toggle between EMPTY, BLOCK, and back
            if (cellValue === EMPTY || cellValue === PLAYER) {
                gameBoard[r][c] = BLOCK;
            } else if (cellValue === BLOCK) {
                gameBoard[r][c] = EMPTY;
            } else if (cellValue === COOKIE) {
                gameTeam[r][c] = BLOCK; // Cookies become blocks
            }
            
            runUpdate();
        }
        
        /**
         * Handles Right-Click events (toggles Cookies)
         */
        function handleRightClick(e) {
            e.preventDefault(); // Stop context menu
            if (isAnimating) return;
            
            const cell = e.target.closest('.cell');
            if (!cell) return;

            const r = parseInt(cell.dataset.r);
            const c = parseInt(cell.dataset.c);
            const cellValue = gameBoard[r][c];

            if (cellValue === WALL) return;
            
            // Your logic: EMPTY -> COOKIE, COOKIE -> EMPTY, BLOCK -> COOKIE
            if (cellValue === EMPTY || cellValue === PLAYER || cellValue === BLOCK) {
                gameBoard[r][c] = COOKIE;
            } else if (cellValue === COOKIE) {
                gameBoard[r][c] = EMPTY;
            }
            
            runUpdate();
        }
        
        /**
         * Helper to run validation and render
         */
        function runUpdate() {
            // Player might be on a toggled square
            if (gameBoard[playerPos.r][playerPos.c] !== PLAYER) {
                 gameBoard[playerPos.r][playerPos.c] = PLAYER;
            }
            validatePuzzle(); 
            renderBoard(); 
        }


        /**
         * Handles arrow key presses (for playing)
         */
        function handleKeyDown(e) {
            if (isAnimating) return; // Ignore input during animation
            
            let dr = 0;
            let dc = 0;

            switch (e.key) {
                case 'ArrowUp':    dr = -1; break;
                case 'ArrowDown':  dr = 1;  break;
                case 'ArrowLeft':  dc = -1; break;
                case 'ArrowRight': dc = 1;  break;
                default: return; // Not an arrow key
            }
            
            e.preventDefault(); // Stop page from scrolling
            movePlayer(dr, dc);
        }

        /**
         * Calculates the player's new position and handles cookie collection
         */
        function movePlayer(dr, dc) {
            let r = playerPos.r, c = playerPos.c;
            let nextR = r + dr, nextC = c + dc;
            
            if (nextR < 0 || nextR >= ROWS || nextC < 0 || nextC >= COLS) return; // Can't move
            
            let nextVal = gameBoard[nextR][nextC];
            if (nextVal === WALL || nextVal === BLOCK) return; // Can't move
            
            isAnimating = true;
            
            // Clear player's old spot
            gameBoard[playerPos.r][playerPos.c] = EMPTY;
            
            // Slide and collect cookies
            while (nextVal === EMPTY || nextVal === PLAYER || nextVal === COOKIE) {
                r = nextR;
                c = nextC;
                
                if (nextVal === COOKIE) {
                    score++;
                    scoreDisplay.textContent = score;
                    gameBoard[r][c] = EMPTY; // "Eat" the cookie
                }

                nextR += dr;
                nextC += dc;
                
                if (nextR < 0 || nextR >= ROWS || nextC < 0 || nextC >= COLS) break; 
                nextVal = gameBoard[nextR][nextC];
            }
            
            // Update state
            playerPos = { r, c };
            gameBoard[r][c] = PLAYER; // Set new spot
            
            // Animate the player element
            animatePlayerToPosition(r, c);
            
            // Re-validate and render
            validatePuzzle();
            renderBoard();
        }
        
        /**
         * Resets the player to the starting position and score to 0
         */
        function resetPlayer() {
            if (isAnimating) return; 
            isAnimating = true; 
            
            // Reset score
            score = 0;
            scoreDisplay.textContent = score;

            // Update data array
            gameBoard[playerPos.r][playerPos.c] = EMPTY;
            
            // Check for cookies at start pos and clear them
            if (gameBoard[playerStartPos.r][playerStartPos.c] === COOKIE) {
                 gameBoard[playerStartPos.r][playerStartPos.c] = EMPTY;
            }
            
            playerPos = { r: playerStartPos.r, c: playerStartPos.c };
            gameBoard[playerStartPos.r][playerStartPos.c] = PLAYER;
            
            // Snap player element back to start
            snapPlayerToPosition(playerPos.r, playerPos.c);
            
            // Re-validate and render
            validatePuzzle();
            renderBoard();
            messageArea.textContent = 'Player and score reset.';
            
            setTimeout(() => { isAnimating = false; }, 50);
        }

        // --- New Validation Logic (BFS Heat Map) ---
        
        /**
         * Runs a BFS to find the *shortest move cost* to all reachable squares.
         */
        function validatePuzzle() {
            moveCosts.clear(); // Use this instead of reachableSquares
            
            let totalSlidableSquares = 0;
            for (let r = 1; r < ROWS - 1; r++) { 
                for (let c = 1; c < COLS - 1; c++) {
                    const val = gameBoard[r][c];
                    if (val === EMPTY || val === PLAYER || val === COOKIE) {
                        totalSlidableSquares++;
                    }
                }
            }
            
            const queue = []; 
            const visitedStops = new Set(); 

            const startKey = `${playerPos.r},${playerPos.c}`;
            queue.push({ r: playerPos.r, c: playerPos.c, cost: 0 }); // Cost = moves to get here
            visitedStops.add(startKey);
            moveCosts.set(startKey, 0);

            let head = 0;
            while (head < queue.length) {
                const { r, c, cost } = queue[head++];

                const directions = [ {dr: -1, dc: 0}, {dr: 1, dc: 0}, {dr: 0, dc: -1}, {dr: 0, dc: 1} ];

                for (const { dr, dc } of directions) {
                    let currR = r, currC = c;
                    let nextR = currR + dr;
                    let nextC = currC + dc;

                    if (nextR < 0 || nextR >= ROWS || nextC < 0 || nextC >= COLS) continue;
                    let nextVal = gameBoard[nextR][nextC];
                    if (nextVal === WALL || nextVal === BLOCK) continue;

                    // Simulate the slide
                    while (nextVal === EMPTY || nextVal === PLAYER || nextVal === COOKIE) {
                        currR = nextR;
                        currC = nextC;
                        
                        // Mark every square on the path with the *same cost*
                        const pathKey = `${currR},${currC}`;
                        if (!moveCosts.has(pathKey)) {
                            moveCosts.set(pathKey, cost + 1);
                        }

                        nextR += dr;
                        nextC += dc;
                        
                        if (nextR < 0 || nextR >= ROWS || nextC < 0 || nextC >= COLS) break; 
                        nextVal = gameBoard[nextR][nextC];
                    }
                    
                    // `(currR, currC)` is the new stopping point
                    const stopKey = `${currR},${currC}`;
                    if (!visitedStops.has(stopKey)) {
                        visitedStops.add(stopKey);
                        queue.push({ r: currR, c: currC, cost: cost + 1 });
                    }
                }
            }

            // --- Validation Check ---
            const reachableCount = moveCosts.size;
            
            const playerKey = `${playerPos.r},${playerPos.c}`;
            playerElement.style.opacity = moveCosts.has(playerKey) ? '1' : '0.5';
 
            if (reachableCount === totalSlidableSquares) {
                messageArea.textContent = `All ${totalSlidableSquares} squares are reachable! (Solvable)`;
                messageArea.classList.add('text-green-400');
                messageArea.classList.remove('text-red-400', 'text-gray-400');
                return true;
            } else {
                messageArea.textContent = `Only ${reachableCount} of ${totalSlidableSquares} squares reachable! (Not Solvable)`;
                messageArea.classList.add('text-red-400');
                messageArea.classList.remove('text-green-400', 'text-gray-400');
                return false;
            }
        }

        // --- New Randomizer Logic ---

        /**
         * Generates a random, solvable puzzle layout.
         */
        function generateRandomLayout() {
            if (isAnimating) return;

            randomButton.textContent = 'Generating...';
            randomButton.disabled = true;
            messageArea.textContent = 'Shuffling the layout...';
            messageArea.classList.remove('text-green-400', 'text-red-400');
            messageArea.classList.add('text-gray-400');
            
            // Reset player to start before randomizing
            resetPlayer();

            // Use setTimeout to allow the UI to update
            setTimeout(() => {
                console.log("--- Starting New Randomization ---");
                // 1. ALWAYS reset to the known-good default layout first
                gameBoard = createInitialMatrix();
                
                const MAX_PERTURBATIONS = 30; // Try 30 "nudges"

                for (let i = 0; i < MAX_PERTURBATIONS; i++) {
                    // 2. Find all current block spots
                    const blocks = [];
                    for (let r = 1; r < ROWS - 1; r++) {
                        for (let c = 1; c < COLS - 1; c++) {
                            if (gameBoard[r][c] === BLOCK) {
                                blocks.push({ r, c });
                            }
                        }
                    }
                    if (blocks.length === 0) break;

                    // 3. Pick one random block
                    const blockToMove = blocks[Math.floor(Math.random() * blocks.length)];
                    
                    // 4. Find its empty neighbors
                    const neighbors = [ {r: -1, c: 0}, {r: 1, c: 0}, {r: 0, c: -1}, {r: 0, c: 1} ];
                    const emptyNeighbors = [];
                    for (const {r: dr, c: dc} of neighbors) {
                        const newR = blockToMove.r + dr;
                        const newC = blockToMove.c + dc;
                        if (gameBoard[newR][newC] === EMPTY) {
                            emptyNeighbors.push({ r: newR, c: newC });
                        }
                    }

                    if (emptyNeighbors.length === 0) {
                        console.log(`Block at ${blockToMove.r},${blockToMove.c} is stuck, skipping.`);
                        continue; // This block is stuck, try another
                    }

                    // 5. Pick one random empty neighbor to "nudge" into
                    const emptySpot = emptyNeighbors[Math.floor(Math.random() * emptyNeighbors.length)];
                    
                    // 6. Try the swap
                    gameBoard[blockToMove.r][blockToMove.c] = EMPTY;
                    gameBoard[emptySpot.r][emptySpot.c] = BLOCK;
                    
                    // 7. Validate. If it's broken, undo the swap.
                    if (!validatePuzzle()) {
                        gameBoard[blockToMove.r][blockToMove.c] = BLOCK;
                        gameBoard[emptySpot.r][emptySpot.c] = EMPTY;
                        console.log(`Nudge ${blockToMove.r},${blockToMove.c} -> ${emptySpot.r},${emptySpot.c} FAILED.`);
                    } else {
                        console.log(`Nudge ${blockToMove.r},${blockToMove.c} -> ${emptySpot.r},${emptySpot.c} SUCCEEDED.`);
                    }
                }
                
                // 8. One final validation to set the message correctly
                console.log("--- Randomization Finished ---");
                validatePuzzle(); 
                
                renderBoard(); // Render the new static board
                randomButton.textContent = 'Randomize';
                randomButton.disabled = false;

            }, 0);
        }

        // --- Start the game ---
        initGame();
        
    </script>
</body>
</html>